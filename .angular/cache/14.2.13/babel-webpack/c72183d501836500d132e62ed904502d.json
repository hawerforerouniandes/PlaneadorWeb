{"ast":null,"code":"'use strict';\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis}\n   */\n\n  var NEWLINE = '\\n';\n  var IGNORE_FRAMES = {};\n  var creationTrace = '__creationTrace__';\n  var ERROR_TAG = 'STACKTRACE TRACKING';\n  var SEP_TAG = '__SEP_TAG__';\n  var sepTemplate = SEP_TAG + '@[native]';\n\n  var LongStackTrace =\n  /** @class */\n  function () {\n    function LongStackTrace() {\n      this.error = getStacktrace();\n      this.timestamp = new Date();\n    }\n\n    return LongStackTrace;\n  }();\n\n  function getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n  }\n\n  function getStacktraceWithCaughtError() {\n    try {\n      throw getStacktraceWithUncaughtError();\n    } catch (err) {\n      return err;\n    }\n  } // Some implementations of exception handling don't create a stack trace if the exception\n  // isn't thrown, however it's faster not to actually throw the exception.\n\n\n  var error = getStacktraceWithUncaughtError();\n  var caughtError = getStacktraceWithCaughtError();\n  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\n  function getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n  }\n\n  function addErrorStack(lines, error) {\n    var trace = getFrames(error);\n\n    for (var i = 0; i < trace.length; i++) {\n      var frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n        lines.push(trace[i]);\n      }\n    }\n  }\n\n  function renderLongStackTrace(frames, stack) {\n    var longTrace = [stack ? stack.trim() : ''];\n\n    if (frames) {\n      var timestamp = new Date().getTime();\n\n      for (var i = 0; i < frames.length; i++) {\n        var traceFrames = frames[i];\n        var lastTime = traceFrames.timestamp;\n        var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n        separator = separator.replace(/[^\\w\\d]/g, '_');\n        longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n        addErrorStack(longTrace, traceFrames.error);\n        timestamp = lastTime.getTime();\n      }\n    }\n\n    return longTrace.join(NEWLINE);\n  } // if Error.stackTraceLimit is 0, means stack trace\n  // is disabled, so we don't need to generate long stack trace\n  // this will improve performance in some test(some test will\n  // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\n  function stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n  }\n\n  Zone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function (error) {\n      if (!error) {\n        return undefined;\n      }\n\n      var trace = error[Zone.__symbol__('currentTaskTrace')];\n\n      if (!trace) {\n        return error.stack;\n      }\n\n      return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (stackTracesEnabled()) {\n        var currentTask = Zone.currentTask;\n        var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n        trace = [new LongStackTrace()].concat(trace);\n\n        if (trace.length > this.longStackTraceLimit) {\n          trace.length = this.longStackTraceLimit;\n        }\n\n        if (!task.data) task.data = {};\n\n        if (task.type === 'eventTask') {\n          // Fix issue https://github.com/angular/zone.js/issues/1195,\n          // For event task of browser, by default, all task will share a\n          // singleton instance of data object, we should create a new one here\n          // The cast to `any` is required to workaround a closure bug which wrongly applies\n          // URL sanitization rules to .data access.\n          task.data = Object.assign({}, task.data);\n        }\n\n        task.data[creationTrace] = trace;\n      }\n\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (stackTracesEnabled()) {\n        var parentTask = Zone.currentTask || error.task;\n\n        if (error instanceof Error && parentTask) {\n          var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n          try {\n            error.stack = error.longStack = longStack;\n          } catch (err) {}\n        }\n      }\n\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  };\n\n  function captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n      stackTraces.push(getFrames(new LongStackTrace().error));\n      captureStackTraces(stackTraces, count - 1);\n    }\n  }\n\n  function computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n      return;\n    }\n\n    var frames = [];\n    captureStackTraces(frames, 2);\n    var frames1 = frames[0];\n    var frames2 = frames[1];\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n\n      if (frame1.indexOf(ERROR_TAG) == -1) {\n        var match = frame1.match(/^\\s*at\\s+/);\n\n        if (match) {\n          sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n      var frame2 = frames2[i];\n\n      if (frame1 === frame2) {\n        IGNORE_FRAMES[frame1] = true;\n      } else {\n        break;\n      }\n    }\n  }\n\n  computeIgnoreFrames();\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ProxyZoneSpec =\n  /** @class */\n  function () {\n    function ProxyZoneSpec(defaultSpecDelegate) {\n      if (defaultSpecDelegate === void 0) {\n        defaultSpecDelegate = null;\n      }\n\n      this.defaultSpecDelegate = defaultSpecDelegate;\n      this.name = 'ProxyZone';\n      this._delegateSpec = null;\n      this.properties = {\n        'ProxyZoneSpec': this\n      };\n      this.propertyKeys = null;\n      this.lastTaskState = null;\n      this.isNeedToTriggerHasTask = false;\n      this.tasks = [];\n      this.setDelegate(defaultSpecDelegate);\n    }\n\n    ProxyZoneSpec.get = function () {\n      return Zone.current.get('ProxyZoneSpec');\n    };\n\n    ProxyZoneSpec.isLoaded = function () {\n      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    };\n\n    ProxyZoneSpec.assertPresent = function () {\n      if (!ProxyZoneSpec.isLoaded()) {\n        throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n      }\n\n      return ProxyZoneSpec.get();\n    };\n\n    ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n      var _this = this;\n\n      var isNewDelegate = this._delegateSpec !== delegateSpec;\n      this._delegateSpec = delegateSpec;\n      this.propertyKeys && this.propertyKeys.forEach(function (key) {\n        return delete _this.properties[key];\n      });\n      this.propertyKeys = null;\n\n      if (delegateSpec && delegateSpec.properties) {\n        this.propertyKeys = Object.keys(delegateSpec.properties);\n        this.propertyKeys.forEach(function (k) {\n          return _this.properties[k] = delegateSpec.properties[k];\n        });\n      } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n        this.isNeedToTriggerHasTask = true;\n      }\n    };\n\n    ProxyZoneSpec.prototype.getDelegate = function () {\n      return this._delegateSpec;\n    };\n\n    ProxyZoneSpec.prototype.resetDelegate = function () {\n      this.getDelegate();\n      this.setDelegate(this.defaultSpecDelegate);\n    };\n\n    ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n      if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n        // last delegateSpec has microTask or macroTask\n        // should call onHasTask in current delegateSpec\n        this.isNeedToTriggerHasTask = false;\n        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n      }\n    };\n\n    ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n      if (!this.tasks) {\n        return;\n      }\n\n      for (var i = 0; i < this.tasks.length; i++) {\n        if (this.tasks[i] === task) {\n          this.tasks.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n      if (this.tasks.length === 0) {\n        return '';\n      }\n\n      var taskInfo = this.tasks.map(function (task) {\n        var dataInfo = task.data && Object.keys(task.data).map(function (key) {\n          return key + ':' + task.data[key];\n        }).join(',');\n        return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n      });\n      var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n      this.tasks = [];\n      return pendingTasksInfo;\n    };\n\n    ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n      if (this._delegateSpec && this._delegateSpec.onFork) {\n        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n      } else {\n        return parentZoneDelegate.fork(targetZone, zoneSpec);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n      if (this._delegateSpec && this._delegateSpec.onIntercept) {\n        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n      } else {\n        return parentZoneDelegate.intercept(targetZone, delegate, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvoke) {\n        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n      } else {\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n      if (this._delegateSpec && this._delegateSpec.onHandleError) {\n        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n      } else {\n        return parentZoneDelegate.handleError(targetZone, error);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.tasks.push(task);\n      }\n\n      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n      } else {\n        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.cancelTask(targetZone, task);\n      }\n    };\n\n    ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n      this.lastTaskState = hasTaskState;\n\n      if (this._delegateSpec && this._delegateSpec.onHasTask) {\n        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n      } else {\n        delegate.hasTask(target, hasTaskState);\n      }\n    };\n\n    return ProxyZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var SyncTestZoneSpec =\n  /** @class */\n  function () {\n    function SyncTestZoneSpec(namePrefix) {\n      this.runZone = Zone.current;\n      this.name = 'syncTestZone for ' + namePrefix;\n    }\n\n    SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n        case 'macroTask':\n          throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test (\").concat(this.name, \").\"));\n\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n\n      return task;\n    };\n\n    return SyncTestZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n    if (!Zone) throw new Error('Missing: zone.js');\n\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current;\n    var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n    if (!ignoreUnhandledRejection) {\n      var globalErrors_1 = jasmine.GlobalErrors;\n\n      if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors_1;\n\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors_1();\n          var originalInstall = instance.install;\n\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n\n            instance.install = function () {\n              var isNode = typeof process !== 'undefined' && !!process.on; // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,\n              // it installs the browser rejection handler through the `global.addEventListener`.\n              // This code may be run in the browser environment where `process` is not defined, and\n              // this will lead to a runtime exception since Webpack 5 removed automatic Node.js\n              // polyfills. Note, that events are named differently, it's `unhandledRejection` in\n              // Node.js and `unhandledrejection` in the browser.\n\n              var originalHandlers = isNode ? process.listeners('unhandledRejection') : global.eventListeners('unhandledrejection');\n              var result = originalInstall.apply(this, arguments);\n              isNode ? process.removeAllListeners('unhandledRejection') : global.removeAllListeners('unhandledrejection');\n\n              if (originalHandlers) {\n                originalHandlers.forEach(function (handler) {\n                  if (isNode) {\n                    process.on('unhandledRejection', handler);\n                  } else {\n                    global.addEventListener('unhandledrejection', handler);\n                  }\n                });\n              }\n\n              return result;\n            };\n          }\n\n          return instance;\n        };\n      }\n    } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn_1 = jasmine[symbol('clock')] = jasmine['clock'];\n\n      jasmine['clock'] = function () {\n        var clock = originalClockFn_1.apply(this, arguments);\n\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick_1 = clock[symbol('tick')] = clock.tick;\n\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n\n            return originalTick_1.apply(this, arguments);\n          };\n\n          var originalMockDate_1 = clock[symbol('mockDate')] = clock.mockDate;\n\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n\n            return originalMockDate_1.apply(this, arguments);\n          }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n\n        return clock;\n      };\n    } // monkey patch createSpyObj to make properties enumerable to true\n\n\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n      var originalCreateSpyObj_1 = jasmine.createSpyObj;\n      jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n\n      jasmine.createSpyObj = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var propertyNames = args.length >= 3 ? args[2] : null;\n        var spyObj;\n\n        if (propertyNames) {\n          var defineProperty_1 = Object.defineProperty;\n\n          Object.defineProperty = function (obj, p, attributes) {\n            return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n              configurable: true,\n              enumerable: true\n            }));\n          };\n\n          try {\n            spyObj = originalCreateSpyObj_1.apply(this, args);\n          } finally {\n            Object.defineProperty = defineProperty_1;\n          }\n        } else {\n          spyObj = originalCreateSpyObj_1.apply(this, args);\n        }\n\n        return spyObj;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(description, describeBody) {\n      return function () {\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe`.\n        var syncZone = ambientZone.fork(new SyncTestZoneSpec(\"jasmine.describe#\".concat(description)));\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n\n\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n\n    var QueueRunner = jasmine.QueueRunner;\n\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n\n      function ZoneQueueRunner(attrs) {\n        var _this = this;\n\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this.testProxyZone = null;\n              _this.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        } // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n\n\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n\n          attrs.userContext.queueRunner = this;\n        } // patch attrs.onException\n\n\n        var onException = attrs.onException;\n\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n\n        _super.call(this, attrs);\n      }\n\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this = this;\n\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n\n          zone = zone.parent;\n        }\n\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('jest', function (context, Zone, api) {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n      return;\n    }\n\n    jest['__zone_patch__'] = true;\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    var proxyZoneSpec = new ProxyZoneSpec();\n    var proxyZone = rootZone.fork(proxyZoneSpec);\n\n    function wrapDescribeFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapDescribeInZone(args[1]);\n          return originalDescribeFn.apply(this, args);\n        };\n      };\n    }\n\n    function wrapTestFactoryInZone(originalJestFn) {\n      return function () {\n        var tableArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          tableArgs[_i] = arguments[_i];\n        }\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          args[1] = wrapTestInZone(args[1]);\n          return originalJestFn.apply(this, tableArgs).apply(this, args);\n        };\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return syncZone.run(describeBody, this, args);\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `proxyZone`.\n     */\n\n\n    function wrapTestInZone(testBody, isTestFunc) {\n      if (isTestFunc === void 0) {\n        isTestFunc = false;\n      }\n\n      if (typeof testBody !== 'function') {\n        return testBody;\n      }\n\n      var wrappedFunc = function () {\n        if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n          // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n          var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n          if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n            testBody = fakeAsyncModule.fakeAsync(testBody);\n          }\n        }\n\n        proxyZoneSpec.isTestFunc = isTestFunc;\n        return proxyZone.run(testBody, null, arguments);\n      }; // Update the length of wrappedFunc to be the same as the length of the testBody\n      // So jest core can handle whether the test function has `done()` or not correctly\n\n\n      Object.defineProperty(wrappedFunc, 'length', {\n        configurable: true,\n        writable: true,\n        enumerable: false\n      });\n      wrappedFunc.length = testBody.length;\n      return wrappedFunc;\n    }\n\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[1] = wrapTestInZone(args[1], true);\n        return originalJestFn.apply(this, args);\n      };\n\n      context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n      context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJestFn = context[methodName];\n\n      if (context[Zone.__symbol__(methodName)]) {\n        return;\n      }\n\n      context[Zone.__symbol__(methodName)] = originalJestFn;\n\n      context[methodName] = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        args[0] = wrapTestInZone(args[0]);\n        return originalJestFn.apply(this, args);\n      };\n    });\n\n    Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n      if (isModern === void 0) {\n        isModern = false;\n      } // check whether currently the test is inside fakeAsync()\n\n\n      function isPatchingFakeTimer() {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        return !!fakeAsyncZoneSpec;\n      } // check whether the current function is inside `test/it` or other methods\n      // such as `describe/beforeEach`\n\n\n      function isInTestFunc() {\n        var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n        return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n      }\n\n      if (Timer[api.symbol('fakeTimers')]) {\n        return;\n      }\n\n      Timer[api.symbol('fakeTimers')] = true; // patch jest fakeTimer internal method to make sure no console.warn print out\n\n      api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n        return function (self, args) {\n          if (isPatchingFakeTimer()) {\n            return true;\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n\n      api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = true;\n\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n\n          return self;\n        };\n      }); // patch useRealTimers(), unset useFakeTimers flag\n\n      api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n        return function (self, args) {\n          Zone[api.symbol('useFakeTimersCalled')] = false;\n\n          if (isModern || isInTestFunc()) {\n            return delegate.apply(self, args);\n          }\n\n          return self;\n        };\n      }); // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n            return fakeAsyncZoneSpec.getRealSystemTime();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runAllTicks(), run all microTasks inside fakeAsync\n\n      api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushMicrotasks();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runAllTimers(), run all macroTasks inside fakeAsync\n\n      api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flush(100, true);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tick(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.flushOnlyPendingTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.tickToNext(args[0]);\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            fakeAsyncZoneSpec.removeAllTimers();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      }); // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n\n      api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n        return function (self, args) {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.getTimerCount();\n          } else {\n            return delegate.apply(self, args);\n          }\n        };\n      });\n    };\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('mocha', function (global, Zone) {\n    var Mocha = global.Mocha;\n\n    if (typeof Mocha === 'undefined') {\n      // return if Mocha is not available, because now zone-testing\n      // will load mocha patch with jasmine/jest patch\n      return;\n    }\n\n    if (typeof Zone === 'undefined') {\n      throw new Error('Missing Zone.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('Missing ProxyZoneSpec');\n    }\n\n    if (Mocha['__zone_patch__']) {\n      throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n\n    Mocha['__zone_patch__'] = true;\n    var rootZone = Zone.current;\n    var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    var testZone = null;\n    var suiteZone = rootZone.fork(new ProxyZoneSpec());\n    var mochaOriginal = {\n      after: global.after,\n      afterEach: global.afterEach,\n      before: global.before,\n      beforeEach: global.beforeEach,\n      describe: global.describe,\n      it: global.it\n    };\n\n    function modifyArguments(args, syncTest, asyncTest) {\n      var _loop_1 = function (i) {\n        var arg = args[i];\n\n        if (typeof arg === 'function') {\n          // The `done` callback is only passed through if the function expects at\n          // least one argument.\n          // Note we have to make a function with correct number of arguments,\n          // otherwise mocha will\n          // think that all functions are sync or async.\n          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n          // correct function body\n\n          args[i].toString = function () {\n            return arg.toString();\n          };\n        }\n      };\n\n      for (var i = 0; i < args.length; i++) {\n        _loop_1(i);\n      }\n\n      return args;\n    }\n\n    function wrapDescribeInZone(args) {\n      var syncTest = function (fn) {\n        return function () {\n          return syncZone.run(fn, this, arguments);\n        };\n      };\n\n      return modifyArguments(args, syncTest);\n    }\n\n    function wrapTestInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return testZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function (fn) {\n        return function () {\n          return testZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    function wrapSuiteInZone(args) {\n      var asyncTest = function (fn) {\n        return function (done) {\n          return suiteZone.run(fn, this, [done]);\n        };\n      };\n\n      var syncTest = function (fn) {\n        return function () {\n          return suiteZone.run(fn, this);\n        };\n      };\n\n      return modifyArguments(args, syncTest, asyncTest);\n    }\n\n    global.describe = global.suite = function () {\n      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.xdescribe = global.suite.skip = function () {\n      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.describe.only = global.suite.only = function () {\n      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n\n    global.it = global.specify = global.test = function () {\n      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.xit = global.xspecify = function () {\n      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.it.only = global.test.only = function () {\n      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.after = global.suiteTeardown = function () {\n      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.afterEach = global.teardown = function () {\n      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    global.before = global.suiteSetup = function () {\n      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n\n    global.beforeEach = global.setup = function () {\n      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n\n    (function (originalRunTest, originalRun) {\n      Mocha.Runner.prototype.runTest = function (fn) {\n        var _this = this;\n\n        Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n          originalRunTest.call(_this, fn);\n        });\n      };\n\n      Mocha.Runner.prototype.run = function (fn) {\n        this.on('test', function (e) {\n          testZone = rootZone.fork(new ProxyZoneSpec());\n        });\n        this.on('fail', function (test, err) {\n          var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n          if (proxyZoneSpec && err) {\n            try {\n              // try catch here in case err.message is not writable\n              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n            } catch (error) {}\n          }\n        });\n        return originalRun.call(this, fn);\n      };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (_global) {\n    var AsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this._existingFinishTimer = null;\n        this.entryFunction = null;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n\n      AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n        return this.unresolvedChainedPromiseCount > 0;\n      };\n\n      AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n        var _this = this; // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n        // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n        // microtasks in the proxy zone that now complete as part of this async zone run.\n        // Consider the following scenario:\n        //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n        //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n        //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n        //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n        //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n        //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n        // If the finish timeout from below is already scheduled, terminate the existing scheduled\n        // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n        // want to schedule a new finish callback in case the task state changes again.\n\n\n        if (this._existingFinishTimer !== null) {\n          clearTimeout(this._existingFinishTimer);\n          this._existingFinishTimer = null;\n        }\n\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n          // We wait until the next tick because we would like to catch unhandled promises which could\n          // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n          this.runZone.run(function () {\n            _this._existingFinishTimer = setTimeout(function () {\n              if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                _this.finishCallback();\n              }\n            }, 0);\n          });\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n        if (patchPromiseForTest) {\n          patchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n        if (unPatchPromiseForTest) {\n          unPatchPromiseForTest();\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n          // check whether the promise is a chained promise\n          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n            // chained promise is being scheduled\n            this.unresolvedChainedPromiseCount--;\n          }\n        }\n\n        return delegate.scheduleTask(target, task);\n      };\n\n      AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      };\n\n      AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.cancelTask(target, task);\n      }; // Note - we need to use onInvoke at the moment to call finish when a test is\n      // fully synchronous. TODO(juliemr): remove this when the logic for\n      // onHasTask changes and it calls whenever the task queues are dirty.\n      // updated by(JiaLiPassion), only call finish callback when no task\n      // was scheduled/invoked/canceled.\n\n\n      AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        if (!this.entryFunction) {\n          this.entryFunction = delegate;\n        }\n\n        try {\n          this._isSync = true;\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        } finally {\n          // We need to check the delegate is the same as entryFunction or not.\n          // Consider the following case.\n          //\n          // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n          //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n          //   });\n          // });\n          //\n          // We only want to check whether there are async tasks scheduled\n          // for the entry function.\n          if (this._isSync && this.entryFunction === delegate) {\n            this._finishCallbackIfDone();\n          }\n        }\n      };\n\n      AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n\n        if (result) {\n          this.failCallback(error);\n          this._alreadyErrored = true;\n        }\n\n        return false;\n      };\n\n      AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState); // We should only trigger finishCallback when the target zone is the AsyncTestZone\n        // Consider the following cases.\n        //\n        // const childZone = asyncTestZone.fork({\n        //   name: 'child',\n        //   onHasTask: ...\n        // });\n        //\n        // So we have nested zones declared the onHasTask hook, in this case,\n        // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n        // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n        // when the current zone is the same as the target zone.\n\n        if (current !== target) {\n          return;\n        }\n\n        if (hasTaskState.change == 'microTask') {\n          this._pendingMicroTasks = hasTaskState.microTask;\n\n          this._finishCallbackIfDone();\n        } else if (hasTaskState.change == 'macroTask') {\n          this._pendingMacroTasks = hasTaskState.macroTask;\n\n          this._finishCallbackIfDone();\n        }\n      };\n\n      return AsyncTestZoneSpec;\n    }();\n\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function () {};\n\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      } // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n\n\n      return function () {\n        var _this = this;\n\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n      };\n    };\n\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/async-test');\n      }\n\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // still this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  (function (global) {\n    var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return new (OriginalDate.bind.apply(OriginalDate, __spreadArray([void 0], args, false)))();\n      }\n    }\n\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getFakeSystemTime();\n      }\n\n      return OriginalDate.now.apply(this, arguments);\n    };\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler =\n    /** @class */\n    function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTickTime = 0; // Current fake system base time in millis.\n\n        this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      Scheduler.prototype.getCurrentTickTime = function () {\n        return this._currentTickTime;\n      };\n\n      Scheduler.prototype.getFakeSystemTime = function () {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      };\n\n      Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      };\n\n      Scheduler.prototype.getRealSystemTime = function () {\n        return OriginalDate.now();\n      };\n\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      };\n\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      };\n\n      Scheduler.prototype.removeAll = function () {\n        this._schedulerQueue = [];\n      };\n\n      Scheduler.prototype.getTimerCount = function () {\n        return this._schedulerQueue.length;\n      };\n\n      Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n        if (step === void 0) {\n          step = 1;\n        }\n\n        if (this._schedulerQueue.length < step) {\n          return;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      };\n\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        var finalTime = this._currentTickTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current_1.endTime;\n\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      };\n\n      Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTickTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTickTime - startTime;\n      };\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          fn.apply(global, args);\n\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this._lastError === null;\n        };\n      };\n\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n        return this._scheduler.getCurrentTickTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n        return this._scheduler.getFakeSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n        return this._scheduler.getRealSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n        if (steps === void 0) {\n          steps = 1;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        if (steps <= 0) {\n          return;\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function () {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        this._scheduler.removeAll();\n\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs = void 0;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n    function getProxyZoneSpec() {\n      return Zone && Zone['ProxyZoneSpec'];\n    }\n\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      var fakeAsyncFn = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var ProxyZoneSpec = getProxyZoneSpec();\n\n        if (!ProxyZoneSpec) {\n          throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n        }\n\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n\n      fakeAsyncFn.isFakeAsync = true;\n      return fakeAsyncFn;\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  }, true);\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * Promise for async/fakeAsync zoneSpec test\n   * can support async operation which not supported by zone.js\n   * such as\n   * it ('test jsonp in AsyncZone', async() => {\n   *   new Promise(res => {\n   *     jsonp(url, (data) => {\n   *       // success callback\n   *       res(data);\n   *     });\n   *   }).then((jsonpResult) => {\n   *     // get jsonp result.\n   *\n   *     // user will expect AsyncZoneSpec wait for\n   *     // then, but because jsonp is not zone aware\n   *     // AsyncZone will finish before then is called.\n   *   });\n   * });\n   */\n\n\n  Zone.__load_patch('promisefortest', function (global, Zone, api) {\n    var symbolState = api.symbol('state');\n    var UNRESOLVED = null;\n    var symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        return;\n      }\n\n      oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n      Promise.prototype.then = function () {\n        var chained = oriThen.apply(this, arguments);\n\n        if (this[symbolState] === UNRESOLVED) {\n          // parent promise is unresolved.\n          var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n          if (asyncTestZoneSpec) {\n            asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n            chained[symbolParentUnresolved] = true;\n          }\n        }\n\n        return chained;\n      };\n    };\n\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n      // restore origin then\n      var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n      if (oriThen) {\n        Promise.prototype.then = oriThen;\n        Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n      }\n    };\n  });\n});","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","factory","define","amd","NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","frame","hasOwnProperty","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","type","Object","assign","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2","ProxyZoneSpec","defaultSpecDelegate","_delegateSpec","properties","propertyKeys","lastTaskState","isNeedToTriggerHasTask","tasks","setDelegate","get","current","isLoaded","assertPresent","delegateSpec","_this","isNewDelegate","forEach","key","keys","k","macroTask","microTask","getDelegate","resetDelegate","tryTriggerHasTask","onHasTask","removeFromTasks","splice","getAndClearPendingTasksInfo","taskInfo","map","dataInfo","source","pendingTasksInfo","onFork","zoneSpec","fork","onIntercept","delegate","intercept","onInvoke","applyThis","applyArgs","invoke","onInvokeTask","invokeTask","onCancelTask","cancelTask","target","hasTaskState","hasTask","SyncTestZoneSpec","namePrefix","runZone","__load_patch","global","api","__extends","d","b","p","__","constructor","create","jest","jasmine","ambientZone","symbol","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors_1","GlobalErrors","instance","originalInstall","install","isNode","process","on","originalHandlers","listeners","eventListeners","result","apply","removeAllListeners","handler","addEventListener","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn_1","clock","originalTick_1","tick","fakeAsyncZoneSpec","originalMockDate_1","mockDate","dateTime","setFakeBaseSystemTime","originalClockFn","FakeAsyncTestZoneSpec","originalCreateSpyObj_1","createSpyObj","args","propertyNames","spyObj","defineProperty_1","defineProperty","obj","attributes","configurable","enumerable","describeBody","syncZone","run","runInTestZone","testBody","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","message","proxyZoneSpec","execute","zone","isChildOfAmbientZone","parent","context","rootZone","proxyZone","wrapDescribeFactoryInZone","originalJestFn","tableArgs","_i","originalDescribeFn","wrapTestFactoryInZone","isTestFunc","wrappedFunc","isFakeAsync","writable","each","describe","only","fdescribe","skip","xdescribe","todo","it","fit","xit","test","patchJestObject","Timer","isModern","isPatchingFakeTimer","isInTestFunc","patchMethod","self","getRealSystemTime","flushMicrotasks","flush","flushOnlyPendingTimers","tickToNext","removeAllTimers","getTimerCount","Mocha","testZone","suiteZone","mochaOriginal","after","afterEach","before","beforeEach","modifyArguments","syncTest","asyncTest","_loop_1","arg","toString","wrapSuiteInZone","suite","specify","xspecify","suiteTeardown","teardown","suiteSetup","setup","originalRunTest","originalRun","Runner","runTest","e","_global","AsyncTestZoneSpec","finishCallback","failCallback","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","_existingFinishTimer","entryFunction","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","isUnresolvedChainedPromisePending","_finishCallbackIfDone","patchPromiseForTest","Promise","unPatchPromiseForTest","symbolParentUnresolved","change","window","fail","getZoneWith","previousDelegate","testZoneSpec","runGuarded","OriginalDate","FakeDate","setTime","now","bind","fakeAsyncTestZoneSpec","getFakeSystemTime","UTC","parse","timers","setInterval","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","getCurrentTickTime","fakeBaseSystemTime","scheduleFunction","cb","delay","options","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","currentEntry","removeScheduledFunctionWithId","removeAll","step","doTick","tickOptions","startTime","targetTask","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","current_1","shift","idx","retval","lastTask","limit","flushPeriodic","flushNonPeriodic","filter","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","pendingPeriodicTimers","pendingTimers","patchDateLocked","assertInZone","_fnAndFlush","completers","onSuccess","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","realTime","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","steps","flushErrors","microtask","elapsed","additionalArgs","callbackIndex","cbIdx","macroTaskOption","findMacroTaskOption","args_1","callbackArgs","handleId","callback","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","fakeAsyncFn","res","lastProxyZoneSpec","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","symbolState","UNRESOLVED","oriThen","then","chained","asyncTestZoneSpec","unpatchPromiseForTest"],"sources":["/Users/hawerforero/Documents/miso/III/Proyectos/UX/PlaneadorWeb/node_modules/zone.js/dist/zone-testing.js"],"sourcesContent":["'use strict';\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n})((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    var NEWLINE = '\\n';\n    var IGNORE_FRAMES = {};\n    var creationTrace = '__creationTrace__';\n    var ERROR_TAG = 'STACKTRACE TRACKING';\n    var SEP_TAG = '__SEP_TAG__';\n    var sepTemplate = SEP_TAG + '@[native]';\n    var LongStackTrace = /** @class */ (function () {\n        function LongStackTrace() {\n            this.error = getStacktrace();\n            this.timestamp = new Date();\n        }\n        return LongStackTrace;\n    }());\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    var error = getStacktraceWithUncaughtError();\n    var caughtError = getStacktraceWithCaughtError();\n    var getStacktrace = error.stack ?\n        getStacktraceWithUncaughtError :\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        var trace = getFrames(error);\n        for (var i = 0; i < trace.length; i++) {\n            var frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        var longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            var timestamp = new Date().getTime();\n            for (var i = 0; i < frames.length; i++) {\n                var traceFrames = frames[i];\n                var lastTime = traceFrames.timestamp;\n                var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10,\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            var trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                var currentTask = Zone.currentTask;\n                var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = Object.assign({}, task.data);\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                var parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames((new LongStackTrace()).error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        var frames = [];\n        captureStackTraces(frames, 2);\n        var frames1 = frames[0];\n        var frames2 = frames[1];\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                var match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            var frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ProxyZoneSpec = /** @class */ (function () {\n        function ProxyZoneSpec(defaultSpecDelegate) {\n            if (defaultSpecDelegate === void 0) { defaultSpecDelegate = null; }\n            this.defaultSpecDelegate = defaultSpecDelegate;\n            this.name = 'ProxyZone';\n            this._delegateSpec = null;\n            this.properties = { 'ProxyZoneSpec': this };\n            this.propertyKeys = null;\n            this.lastTaskState = null;\n            this.isNeedToTriggerHasTask = false;\n            this.tasks = [];\n            this.setDelegate(defaultSpecDelegate);\n        }\n        ProxyZoneSpec.get = function () {\n            return Zone.current.get('ProxyZoneSpec');\n        };\n        ProxyZoneSpec.isLoaded = function () {\n            return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n        };\n        ProxyZoneSpec.assertPresent = function () {\n            if (!ProxyZoneSpec.isLoaded()) {\n                throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n            }\n            return ProxyZoneSpec.get();\n        };\n        ProxyZoneSpec.prototype.setDelegate = function (delegateSpec) {\n            var _this = this;\n            var isNewDelegate = this._delegateSpec !== delegateSpec;\n            this._delegateSpec = delegateSpec;\n            this.propertyKeys && this.propertyKeys.forEach(function (key) { return delete _this.properties[key]; });\n            this.propertyKeys = null;\n            if (delegateSpec && delegateSpec.properties) {\n                this.propertyKeys = Object.keys(delegateSpec.properties);\n                this.propertyKeys.forEach(function (k) { return _this.properties[k] = delegateSpec.properties[k]; });\n            }\n            // if a new delegateSpec was set, check if we need to trigger hasTask\n            if (isNewDelegate && this.lastTaskState &&\n                (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n                this.isNeedToTriggerHasTask = true;\n            }\n        };\n        ProxyZoneSpec.prototype.getDelegate = function () {\n            return this._delegateSpec;\n        };\n        ProxyZoneSpec.prototype.resetDelegate = function () {\n            this.getDelegate();\n            this.setDelegate(this.defaultSpecDelegate);\n        };\n        ProxyZoneSpec.prototype.tryTriggerHasTask = function (parentZoneDelegate, currentZone, targetZone) {\n            if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n                // last delegateSpec has microTask or macroTask\n                // should call onHasTask in current delegateSpec\n                this.isNeedToTriggerHasTask = false;\n                this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n            }\n        };\n        ProxyZoneSpec.prototype.removeFromTasks = function (task) {\n            if (!this.tasks) {\n                return;\n            }\n            for (var i = 0; i < this.tasks.length; i++) {\n                if (this.tasks[i] === task) {\n                    this.tasks.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        ProxyZoneSpec.prototype.getAndClearPendingTasksInfo = function () {\n            if (this.tasks.length === 0) {\n                return '';\n            }\n            var taskInfo = this.tasks.map(function (task) {\n                var dataInfo = task.data &&\n                    Object.keys(task.data)\n                        .map(function (key) {\n                        return key + ':' + task.data[key];\n                    })\n                        .join(',');\n                return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n            });\n            var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n            // clear tasks\n            this.tasks = [];\n            return pendingTasksInfo;\n        };\n        ProxyZoneSpec.prototype.onFork = function (parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n            if (this._delegateSpec && this._delegateSpec.onFork) {\n                return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n            }\n            else {\n                return parentZoneDelegate.fork(targetZone, zoneSpec);\n            }\n        };\n        ProxyZoneSpec.prototype.onIntercept = function (parentZoneDelegate, currentZone, targetZone, delegate, source) {\n            if (this._delegateSpec && this._delegateSpec.onIntercept) {\n                return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n            }\n            else {\n                return parentZoneDelegate.intercept(targetZone, delegate, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvoke) {\n                return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n            }\n            else {\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n        };\n        ProxyZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (this._delegateSpec && this._delegateSpec.onHandleError) {\n                return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n            }\n            else {\n                return parentZoneDelegate.handleError(targetZone, error);\n            }\n        };\n        ProxyZoneSpec.prototype.onScheduleTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.tasks.push(task);\n            }\n            if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n                return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.scheduleTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onInvokeTask = function (parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n                return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n            }\n            else {\n                return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n            }\n        };\n        ProxyZoneSpec.prototype.onCancelTask = function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (task.type !== 'eventTask') {\n                this.removeFromTasks(task);\n            }\n            this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n            if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n                return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n            }\n            else {\n                return parentZoneDelegate.cancelTask(targetZone, task);\n            }\n        };\n        ProxyZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n            this.lastTaskState = hasTaskState;\n            if (this._delegateSpec && this._delegateSpec.onHasTask) {\n                this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n            }\n            else {\n                delegate.hasTask(target, hasTaskState);\n            }\n        };\n        return ProxyZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['ProxyZoneSpec'] = ProxyZoneSpec;\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var SyncTestZoneSpec = /** @class */ (function () {\n        function SyncTestZoneSpec(namePrefix) {\n            this.runZone = Zone.current;\n            this.name = 'syncTestZone for ' + namePrefix;\n        }\n        SyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                case 'macroTask':\n                    throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test (\").concat(this.name, \").\"));\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        };\n        return SyncTestZoneSpec;\n    }());\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jasmine', function (global, Zone, api) {\n        var __extends = function (d, b) {\n            for (var p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        var ambientZone = Zone.current;\n        var symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            var globalErrors_1 = jasmine.GlobalErrors;\n            if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors_1;\n                jasmine.GlobalErrors = function () {\n                    var instance = new globalErrors_1();\n                    var originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            var isNode = typeof process !== 'undefined' && !!process.on;\n                            // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,\n                            // it installs the browser rejection handler through the `global.addEventListener`.\n                            // This code may be run in the browser environment where `process` is not defined, and\n                            // this will lead to a runtime exception since Webpack 5 removed automatic Node.js\n                            // polyfills. Note, that events are named differently, it's `unhandledRejection` in\n                            // Node.js and `unhandledrejection` in the browser.\n                            var originalHandlers = isNode ? process.listeners('unhandledRejection') :\n                                global.eventListeners('unhandledrejection');\n                            var result = originalInstall.apply(this, arguments);\n                            isNode ? process.removeAllListeners('unhandledRejection') :\n                                global.removeAllListeners('unhandledrejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(function (handler) {\n                                    if (isNode) {\n                                        process.on('unhandledRejection', handler);\n                                    }\n                                    else {\n                                        global.addEventListener('unhandledrejection', handler);\n                                    }\n                                });\n                            }\n                            return result;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        var jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            var originalClockFn_1 = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                var clock = originalClockFn_1.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    var originalTick_1 = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick_1.apply(this, arguments);\n                    };\n                    var originalMockDate_1 = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate_1.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(function (methodName) {\n                            var originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            var originalCreateSpyObj_1 = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n            jasmine.createSpyObj = function () {\n                var args = Array.prototype.slice.call(arguments);\n                var propertyNames = args.length >= 3 ? args[2] : null;\n                var spyObj;\n                if (propertyNames) {\n                    var defineProperty_1 = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj_1.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty_1;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj_1.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(description, describeBody) {\n            return function () {\n                // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n                // error if any asynchronous operations are attempted inside of a `describe`.\n                var syncZone = ambientZone.fork(new SyncTestZoneSpec(\"jasmine.describe#\".concat(description)));\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            queueRunner.testProxyZoneSpec;\n            var testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        var QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                var _this = this;\n                if (attrs.onComplete) {\n                    attrs.onComplete = (function (fn) { return function () {\n                        // All functions are done, clear the test zone.\n                        _this.testProxyZone = null;\n                        _this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    }; })(attrs.onComplete);\n                }\n                var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                var onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        var proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                var _this = this;\n                var zone = Zone.current;\n                var isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () { return QueueRunner.prototype.execute.call(_this); });\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jest', function (context, Zone, api) {\n        if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n            return;\n        }\n        jest['__zone_patch__'] = true;\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n        var proxyZoneSpec = new ProxyZoneSpec();\n        var proxyZone = rootZone.fork(proxyZoneSpec);\n        function wrapDescribeFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapDescribeInZone(args[1]);\n                    return originalDescribeFn.apply(this, args);\n                };\n            };\n        }\n        function wrapTestFactoryInZone(originalJestFn) {\n            return function () {\n                var tableArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    tableArgs[_i] = arguments[_i];\n                }\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    args[1] = wrapTestInZone(args[1]);\n                    return originalJestFn.apply(this, tableArgs).apply(this, args);\n                };\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return syncZone.run(describeBody, this, args);\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in the `proxyZone`.\n         */\n        function wrapTestInZone(testBody, isTestFunc) {\n            if (isTestFunc === void 0) { isTestFunc = false; }\n            if (typeof testBody !== 'function') {\n                return testBody;\n            }\n            var wrappedFunc = function () {\n                if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody &&\n                    !testBody.isFakeAsync) {\n                    // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n                    var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                    if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                        testBody = fakeAsyncModule.fakeAsync(testBody);\n                    }\n                }\n                proxyZoneSpec.isTestFunc = isTestFunc;\n                return proxyZone.run(testBody, null, arguments);\n            };\n            // Update the length of wrappedFunc to be the same as the length of the testBody\n            // So jest core can handle whether the test function has `done()` or not correctly\n            Object.defineProperty(wrappedFunc, 'length', { configurable: true, writable: true, enumerable: false });\n            wrappedFunc.length = testBody.length;\n            return wrappedFunc;\n        }\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n        });\n        context.describe.only = context.fdescribe;\n        context.describe.skip = context.xdescribe;\n        ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[1] = wrapTestInZone(args[1], true);\n                return originalJestFn.apply(this, args);\n            };\n            context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n            context[methodName].todo = originalJestFn.todo;\n        });\n        context.it.only = context.fit;\n        context.it.skip = context.xit;\n        context.test.only = context.fit;\n        context.test.skip = context.xit;\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJestFn = context[methodName];\n            if (context[Zone.__symbol__(methodName)]) {\n                return;\n            }\n            context[Zone.__symbol__(methodName)] = originalJestFn;\n            context[methodName] = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                args[0] = wrapTestInZone(args[0]);\n                return originalJestFn.apply(this, args);\n            };\n        });\n        Zone.patchJestObject = function patchJestObject(Timer, isModern) {\n            if (isModern === void 0) { isModern = false; }\n            // check whether currently the test is inside fakeAsync()\n            function isPatchingFakeTimer() {\n                var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                return !!fakeAsyncZoneSpec;\n            }\n            // check whether the current function is inside `test/it` or other methods\n            // such as `describe/beforeEach`\n            function isInTestFunc() {\n                var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n                return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n            }\n            if (Timer[api.symbol('fakeTimers')]) {\n                return;\n            }\n            Timer[api.symbol('fakeTimers')] = true;\n            // patch jest fakeTimer internal method to make sure no console.warn print out\n            api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n                return function (self, args) {\n                    if (isPatchingFakeTimer()) {\n                        return true;\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n            api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = true;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch useRealTimers(), unset useFakeTimers flag\n            api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n                return function (self, args) {\n                    Zone[api.symbol('useFakeTimersCalled')] = false;\n                    if (isModern || isInTestFunc()) {\n                        return delegate.apply(self, args);\n                    }\n                    return self;\n                };\n            });\n            // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                        return fakeAsyncZoneSpec.getRealSystemTime();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTicks(), run all microTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushMicrotasks();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runAllTimers(), run all macroTasks inside fakeAsync\n            api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flush(100, true);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tick(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.flushOnlyPendingTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n            api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.tickToNext(args[0]);\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n            api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        fakeAsyncZoneSpec.removeAllTimers();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n            // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n            api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n                return function (self, args) {\n                    var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        return fakeAsyncZoneSpec.getTimerCount();\n                    }\n                    else {\n                        return delegate.apply(self, args);\n                    }\n                };\n            });\n        };\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('mocha', function (global, Zone) {\n        var Mocha = global.Mocha;\n        if (typeof Mocha === 'undefined') {\n            // return if Mocha is not available, because now zone-testing\n            // will load mocha patch with jasmine/jest patch\n            return;\n        }\n        if (typeof Zone === 'undefined') {\n            throw new Error('Missing Zone.js');\n        }\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('Missing ProxyZoneSpec');\n        }\n        if (Mocha['__zone_patch__']) {\n            throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n        }\n        Mocha['__zone_patch__'] = true;\n        var rootZone = Zone.current;\n        var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n        var testZone = null;\n        var suiteZone = rootZone.fork(new ProxyZoneSpec());\n        var mochaOriginal = {\n            after: global.after,\n            afterEach: global.afterEach,\n            before: global.before,\n            beforeEach: global.beforeEach,\n            describe: global.describe,\n            it: global.it\n        };\n        function modifyArguments(args, syncTest, asyncTest) {\n            var _loop_1 = function (i) {\n                var arg = args[i];\n                if (typeof arg === 'function') {\n                    // The `done` callback is only passed through if the function expects at\n                    // least one argument.\n                    // Note we have to make a function with correct number of arguments,\n                    // otherwise mocha will\n                    // think that all functions are sync or async.\n                    args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                    // Mocha uses toString to view the test body in the result list, make sure we return the\n                    // correct function body\n                    args[i].toString = function () {\n                        return arg.toString();\n                    };\n                }\n            };\n            for (var i = 0; i < args.length; i++) {\n                _loop_1(i);\n            }\n            return args;\n        }\n        function wrapDescribeInZone(args) {\n            var syncTest = function (fn) {\n                return function () {\n                    return syncZone.run(fn, this, arguments);\n                };\n            };\n            return modifyArguments(args, syncTest);\n        }\n        function wrapTestInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return testZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return testZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        function wrapSuiteInZone(args) {\n            var asyncTest = function (fn) {\n                return function (done) {\n                    return suiteZone.run(fn, this, [done]);\n                };\n            };\n            var syncTest = function (fn) {\n                return function () {\n                    return suiteZone.run(fn, this);\n                };\n            };\n            return modifyArguments(args, syncTest, asyncTest);\n        }\n        global.describe = global.suite = function () {\n            return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.xdescribe = global.suite.skip = function () {\n            return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.describe.only = global.suite.only = function () {\n            return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n        };\n        global.it = global.specify = global.test = function () {\n            return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n        };\n        global.xit = global.xspecify = function () {\n            return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n        };\n        global.it.only = global.test.only = function () {\n            return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n        };\n        global.after = global.suiteTeardown = function () {\n            return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.afterEach = global.teardown = function () {\n            return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n        };\n        global.before = global.suiteSetup = function () {\n            return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n        };\n        global.beforeEach = global.setup = function () {\n            return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n        };\n        (function (originalRunTest, originalRun) {\n            Mocha.Runner.prototype.runTest = function (fn) {\n                var _this = this;\n                Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n                    originalRunTest.call(_this, fn);\n                });\n            };\n            Mocha.Runner.prototype.run = function (fn) {\n                this.on('test', function (e) {\n                    testZone = rootZone.fork(new ProxyZoneSpec());\n                });\n                this.on('fail', function (test, err) {\n                    var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                    if (proxyZoneSpec && err) {\n                        try {\n                            // try catch here in case err.message is not writable\n                            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                        }\n                        catch (error) {\n                        }\n                    }\n                });\n                return originalRun.call(this, fn);\n            };\n        })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (_global) {\n        var AsyncTestZoneSpec = /** @class */ (function () {\n            function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this._existingFinishTimer = null;\n                this.entryFunction = null;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n                return this.unresolvedChainedPromiseCount > 0;\n            };\n            AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n                var _this = this;\n                // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n                // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n                // microtasks in the proxy zone that now complete as part of this async zone run.\n                // Consider the following scenario:\n                //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n                //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n                //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n                //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n                //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n                //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n                // If the finish timeout from below is already scheduled, terminate the existing scheduled\n                // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n                // want to schedule a new finish callback in case the task state changes again.\n                if (this._existingFinishTimer !== null) {\n                    clearTimeout(this._existingFinishTimer);\n                    this._existingFinishTimer = null;\n                }\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                    // We wait until the next tick because we would like to catch unhandled promises which could\n                    // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n                    this.runZone.run(function () {\n                        _this._existingFinishTimer = setTimeout(function () {\n                            if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                                _this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            };\n            AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            };\n            AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            };\n            AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            };\n            AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            };\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                if (!this.entryFunction) {\n                    this.entryFunction = delegate;\n                }\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    // We need to check the delegate is the same as entryFunction or not.\n                    // Consider the following case.\n                    //\n                    // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n                    //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n                    //   });\n                    // });\n                    //\n                    // We only want to check whether there are async tasks scheduled\n                    // for the entry function.\n                    if (this._isSync && this.entryFunction === delegate) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            };\n            AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                var result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            };\n            AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                // We should only trigger finishCallback when the target zone is the AsyncTestZone\n                // Consider the following cases.\n                //\n                // const childZone = asyncTestZone.fork({\n                //   name: 'child',\n                //   onHasTask: ...\n                // });\n                //\n                // So we have nested zones declared the onHasTask hook, in this case,\n                // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n                // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n                // when the current zone is the same as the target zone.\n                if (current !== target) {\n                    return;\n                }\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            };\n            return AsyncTestZoneSpec;\n        }());\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n    Zone.__load_patch('asynctest', function (global, Zone, api) {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, function (err) {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                var _this = this;\n                return new Promise(function (finishCallback, failCallback) {\n                    runInTestZone(fn, _this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            var currentZone = Zone.current;\n            var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/async-test');\n            }\n            var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/proxy');\n            }\n            var proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            var previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(function () {\n                var testZoneSpec = new AsyncTestZoneSpec(function () {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // still this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        finishCallback();\n                    });\n                }, function (error) {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(function () {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        var OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                var d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                var args = Array.prototype.slice.call(arguments);\n                return new (OriginalDate.bind.apply(OriginalDate, __spreadArray([void 0], args, false)))();\n            }\n        }\n        FakeDate.now = function () {\n            var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncTestZoneSpec) {\n                return fakeAsyncTestZoneSpec.getFakeSystemTime();\n            }\n            return OriginalDate.now.apply(this, arguments);\n        };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTickTime = 0;\n                // Current fake system base time in millis.\n                this._currentFakeBaseSystemTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTickTime = function () {\n                return this._currentTickTime;\n            };\n            Scheduler.prototype.getFakeSystemTime = function () {\n                return this._currentFakeBaseSystemTime + this._currentTickTime;\n            };\n            Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n                this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n            };\n            Scheduler.prototype.getRealSystemTime = function () {\n                return OriginalDate.now();\n            };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTickTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.removeAll = function () {\n                this._schedulerQueue = [];\n            };\n            Scheduler.prototype.getTimerCount = function () {\n                return this._schedulerQueue.length;\n            };\n            Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n                if (step === void 0) { step = 1; }\n                if (this._schedulerQueue.length < step) {\n                    return;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var targetTask = this._schedulerQueue[step - 1];\n                this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTickTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTickTime;\n                        this._currentTickTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTickTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTickTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTickTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n                return this._scheduler.getCurrentTickTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n                return this._scheduler.getFakeSystemTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n                this._scheduler.setFakeBaseSystemTime(realTime);\n            };\n            FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n                return this._scheduler.getRealSystemTime();\n            };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n                if (steps === void 0) { steps = 1; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                if (steps <= 0) {\n                    return;\n                }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tickToNext(steps, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this._scheduler.removeAll();\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n            };\n            FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n                return this._scheduler.getTimerCount() + this._microtasks.length;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        function getProxyZoneSpec() {\n            return Zone && Zone['ProxyZoneSpec'];\n        }\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            var fakeAsyncFn = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var ProxyZoneSpec = getProxyZoneSpec();\n                if (!ProxyZoneSpec) {\n                    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                        'Please make sure that your environment includes zone.js/plugins/proxy');\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n            fakeAsyncFn.isFakeAsync = true;\n            return fakeAsyncFn;\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync };\n    }, true);\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Promise for async/fakeAsync zoneSpec test\n     * can support async operation which not supported by zone.js\n     * such as\n     * it ('test jsonp in AsyncZone', async() => {\n     *   new Promise(res => {\n     *     jsonp(url, (data) => {\n     *       // success callback\n     *       res(data);\n     *     });\n     *   }).then((jsonpResult) => {\n     *     // get jsonp result.\n     *\n     *     // user will expect AsyncZoneSpec wait for\n     *     // then, but because jsonp is not zone aware\n     *     // AsyncZone will finish before then is called.\n     *   });\n     * });\n     */\n    Zone.__load_patch('promisefortest', function (global, Zone, api) {\n        var symbolState = api.symbol('state');\n        var UNRESOLVED = null;\n        var symbolParentUnresolved = api.symbol('parentUnresolved');\n        // patch Promise.prototype.then to keep an internal\n        // number for tracking unresolved chained promise\n        // we will decrease this number when the parent promise\n        // being resolved/rejected and chained promise was\n        // scheduled as a microTask.\n        // so we can know such kind of chained promise still\n        // not resolved in AsyncTestZone\n        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                return;\n            }\n            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n            Promise.prototype.then = function () {\n                var chained = oriThen.apply(this, arguments);\n                if (this[symbolState] === UNRESOLVED) {\n                    // parent promise is unresolved.\n                    var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                    if (asyncTestZoneSpec) {\n                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                        chained[symbolParentUnresolved] = true;\n                    }\n                }\n                return chained;\n            };\n        };\n        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n            // restore origin then\n            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n            if (oriThen) {\n                Promise.prototype.then = oriThen;\n                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n            }\n        };\n    });\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}